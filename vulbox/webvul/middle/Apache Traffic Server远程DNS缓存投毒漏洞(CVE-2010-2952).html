
<!DOCTYPE html>

<html>

	<head>

		<meta charset="utf-8">

        <link rel="stylesheet" href="/vulbox/source/table.css" />

	</head>

	<body class="dialog">

		<div class="content">

			<div class="wrap">

				<div class="cont">

					<table class="table table-hover table-mc-light-blue" style="margin-top: 0;">

						<thead>

							<tr class="first_title">

								<th colspan="2">漏洞描述</th>

							</tr>

						</thead>

						<tbody>

							<tr>

								<th width="70">漏洞名称</th>

								<td>

								    <img style="float:left;" src="/vulbox/source/m.gif" align="absmiddle"/>

								<span style="float:left;margin-top:1px;margin-top:2px\9;">Apache Traffic Server远程DNS缓存投毒漏洞(CVE-2010-2952)</span>

								</td>

							</tr>

							<tr>

								<th valign="top">详细描述</th>

								<td valign="top">

									Apache Traffic Server是高效、可扩展的缓存代理服务器。<br />

									<br />

									Traffic Server根据DNS服务器使用了静态的源端口执行出站DNS查询。在运行时使用了iocore/dns/DNSConnection.cc中的DNSConnection::connect()方式来选择端口：<br />

									<br />

									struct sockaddr_in bind_sa;<br />

									memset(&amp;sa, 0, sizeof(bind_sa));<br />

									bind_sa.sin_family = AF_INET;<br />

									bind_sa.sin_addr.s_addr = INADDR_ANY;<br />

									int p = time(NULL) + offset;<br />

									p = (p  (LAST_RANDOM_PORT - FIRST_RANDOM_PORT)) + FIRST_RANDOM_PORT;<br />

									bind_sa.sin_port = htons(p);<br />

									Debug(&quot;dns&quot;, &quot;random port = d\n&quot;, p);<br />

									if ((res = socketManager.ink_bind(fd, (struct sockaddr *) &amp;bind_sa, sizeof(bind_sa), Proto)) &lt; 0) {<br />

									    offset += 101;<br />

									    continue;<br />

									}<br />

									<br />

									由于FIRST_RANDOM_PORT设置为了16000，LAST_RANDOM_PORT定义为32000，且基础算法是可预测的，因此可以猜测到源端口。<br />

									<br />

									Traffic Server对查询使用了顺序的DNS事务处理ID，在运行时使用了iocore/dns/DNS.cc中的DNSProcessor::dns_init()来设置基准号：<br />

									<br />

									if (cval &gt; 0) {<br />

									    dns_sequence_number = (unsigned int) (cval + DNS_SEQUENCE_NUMBER_RESTART_OFFSET);<br />

									    Debug(&quot;dns&quot;, &quot;initial dns_sequence_number (cval) = d\n&quot;, (u_short) dns_sequence_number);<br />

									} else {                    // select a sequence number at random<br />

									    dns_sequence_number = (unsigned int) (ink_get_hrtime() / HRTIME_MSECOND);<br />

									    Debug(&quot;dns&quot;, &quot;initial dns_sequence_number (time) = d\n&quot;, (u_short) dns_sequence_number);<br />

									}<br />

									<br />

									如write_dns_event()函数所示，每一个请求进行一次递增：<br />

									<br />

									++dns_sequence_number;<br />

									... <br />

									u_short i = (u_short) dns_sequence_number;<br />

									((HEADER *) (buffer))-&gt;id = htons(i);<br />

									<br />

									在处理请求时，Traffic Server执行一个包含有每个所尝试请求细节的链表，并将入站ID与该表做比较以确定请求与响应的关联，如iocore/dns/DNS.cc文件中的dns_process()函数所示：<br />

									<br />

									DNSEntry *e = get_dns(handler, (u_short) ntohs(h-&gt;id));<br />

									...<br />

									inline static DNSEntry *<br />

									get_dns(DNSHandler * h, u_short id)<br />

									{<br />

									    for (DNSEntry * e = h-&gt;entries.head; e; e = (DNSEntry *) e-&gt;link.next) {<br />

									        if (e-&gt;once_written_flag)<br />

									    for (int j = 0; j &lt; MAX_DNS_RETRIES; j++)<br />

									        if (e-&gt;id[j] == id)<br />

									            return e;<br />

									        else if (e-&gt;id[j] &lt; 0)<br />

									            goto Lnext;<br />

									        Lnext:;<br />

									    }<br />

									    return NULL;<br />

									}<br />

									<br />

									由于Traffic Server没有验证DNS请求已确保其关联到正确的出站请求，而仅是依赖于事务处理ID来验证响应，这极大的增加了向内部DNS缓存投毒的概率。<br />

									<br />

									&lt;*来源：Tim Brown （securityfocus@machine.org.uk）<br />

									  <br />

									  链接：http://secunia.com/advisories/41356/<br />

									        http://www.nth-dimension.org.uk/pub/NDSA20100830.txt.asc<br />

									*&gt;<br />

								</td>

							</tr>

							<tr>

								<th  valign="top">解决方案</th>

								<td valign="top">

									厂商补丁：<br />

									<br />

									Apache Group<br />

									------------<br />

									目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载：<br />

									<br />

									https://issues.apache.org/jira/si/jira.issueviews:issue-html/TS-425/TS-425.html<br />

								</td>

							</tr>

							<tr>

								<th>威胁分值</th>

								<td>4</td>

							</tr>

							<tr>

								<th>危险插件</th>

								<td>否</td>

							</tr>

							<tr>

                                <th>发现日期</th>

                                <td>2010-09-13</td>

                            </tr>

							<tr>

                                <th>发布日期</th>

                                <td>2013-04-25</td>

                            </tr>

							<tr>

								<th>CVE</th>

								<td>

									<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2952" target="_blank">CVE-2010-2952</a>&nbsp;

								</td>

							</tr>

							<tr>

								<th>BUGTRAQ</th>

								<td>

									<a href="http://www.securityfocus.com/bid/43111" target="_blank">43111</a>

								</td>

							</tr>

							<tr>

								<th>NSFOCUS</th>

								<td>

									<a href="http://www.nsfocus.net/index.php?act=sec_bug&do=view&bug_id=15731" target="_blank">15731</a>

								</td>

							</tr>

							<tr>

								<th>CNNVD编号</th>

								<td>

									CNNVD-201009-105&nbsp;&nbsp;

								</td>

							</tr>

							<tr>

								<th>CNCVE编号</th>

								<td>

									CNCVE-20102952&nbsp;&nbsp;

								</td>

							</tr>

							<tr>

								<th>CVSS评分</th>

								<td>

									4.3&nbsp;&nbsp;

								</td>

							</tr>

							<tr>

								<th>CNVD编号</th>

								<td>

									CNVD-2010-1915&nbsp;&nbsp;

								</td>

							</tr>

						</tbody>

					</table>

				</div>

			</div>

		</div>

	</body>

</html>